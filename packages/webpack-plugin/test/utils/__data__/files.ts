import { CACHE_PATH, ContentsApiResponse } from "../../../src/utils/get-subsets";
import path from "node:path";

export const MOCK_FILE_INFO: Record<string, string> = {};

MOCK_FILE_INFO[`${CACHE_PATH}/slices/korean_default.txt`] =
	`# Generated by a tool; DO NOT MODIFY BY HAND

# 100 codepoints FreqRange target_len 100 actual_len 100
subsets {
	codepoints: 44256 # 고 HANGUL SYLLABLE GO
	codepoints: 50577 # 양 HANGUL SYLLABLE YANG
	codepoints: 51060 # 이 HANGUL SYLLABLE I
}
# 100 codepoints FreqRange target_len 100 actual_len 100
subsets {
    codepoints: 44053 # 강 HANGUL SYLLABLE GANG
	codepoints: 50500 # 아 HANGUL SYLLABLE A
	codepoints: 51648 # 지 HANGUL SYLLABLE JI
}
`;
MOCK_FILE_INFO[`${CACHE_PATH}/slices/traditional-chinese_default.txt`] =
	`# Generated by a tool; DO NOT MODIFY BY HAND

# 176 codepoints FreqRange target_len 50 actual_len 176
subsets {
    codepoints: 35987 # 貓 CJK UNIFIED IDEOGRAPH-8C93
}
`;
MOCK_FILE_INFO[`${CACHE_PATH}/slices/japanese_default.txt`] =
	`# Generated by a tool; DO NOT MODIFY BY HAND

# 176 codepoints FreqRange target_len 50 actual_len 176
subsets {
	codepoints: 12397 # ね HIRAGANA LETTER NE
	codepoints: 12371 # こ HIRAGANA LETTER KO
}
`;
MOCK_FILE_INFO[`${CACHE_PATH}/subsets/latin_unique-glyphs.nam`] =
	`# This file was generated by preprocess_namfile.py

0x0043 LATIN CAPITAL LETTER C
0x0041 LATIN CAPITAL LETTER A
0x0054 LATIN CAPITAL LETTER T
`;
MOCK_FILE_INFO[`${CACHE_PATH}/subsets/cyrillic_unique-glyphs.nam`] =
	`# This file was generated by preprocess_namfile.py

0x043A CYRILLIC SMALL LETTER KA
0x043E CYRILLIC SMALL LETTER O
0x0448 CYRILLIC SMALL LETTER SHA
0x0430 CYRILLIC SMALL LETTER A
`;
MOCK_FILE_INFO[`${CACHE_PATH}/subsets/chinese-traditional_unique-glyphs.nam`] =
	`# This file was generated by preprocess_namfile.py

0x8C93
`;

export function getMockedFetchResponse(url: string): Array<ContentsApiResponse> {
	const files: Array<ContentsApiResponse> = [];
	if (url.includes("/gfsubsets/")) {
		files.push(
			...Object.keys(MOCK_FILE_INFO)
				.filter((filePath) => filePath.includes("subsets"))
				.map((filePath) => ({
					name: path.basename(filePath),
					download_url: "#",
					type: "file",
				})),
		);
	} else if (url.endsWith("/slices")) {
		files.push(
			...Object.keys(MOCK_FILE_INFO)
				.filter((filePath) => filePath.includes("slices"))
				.map((filePath) => ({
					name: path.basename(filePath),
					download_url: "#",
					type: "file",
				})),
		);
	}
	return files;
}

export function getMockedReaddirResponse(dir: string): Array<string> {
	return Object.keys(MOCK_FILE_INFO)
		.filter((filePath) => filePath.startsWith(dir))
		.map((filePath) => path.basename(filePath));
}
